# Job Description to Markdown

```elixir
Mix.install([
  {:kino, github: "livebook-dev/kino", override: true},
  {:kino_lab, "~> 0.1.0-dev", github: "jonatanklosko/kino_lab"},
  # {:kino_vega_lite, "~> 0.1.1"},
  # {:kino_db, "~> 0.1.1"},
  {:req, github: "wojtekmach/req"},
  {:req_easyhtml, github: "wojtekmach/req_easyhtml"},
  {:floki, "~> 0.32"},
  {:pandex, "~> 0.2.0"}
])
```

## Summary

Using the excellent `req` library, we want to get the HTML of the job post url and convert the contents to markdown.

## Specifications

1. If `<temporary html file does not exist>:`
   1. Use `req` to download the full HTML page into `data/#{host}/#{hash}.html`.
2. If `<temporary html file exists>:`
   1. Ask to overwrite?
   2. Skip to next step (3).
3. Detect ATS system, one of `[breezyhr, greenhouse, lever, unknown]`
4. Parse HTML into Markdown
   1. [x] Pandoc
   2. [ ] Manually
   3. [ ] EasyHTML - Was unaware this was just a wrapper around Floki
5. Add `[ ]` to every list item
   1. We do this specifically to help with a manual checklist.
   2. I would not apply to a position that had very few checked off.
   3. This list conversion has been almost 100% universal, to the point that this process should "be a thing."

## Code

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
url = Kino.Input.url("URL")
```

```elixir
defmodule Persistence do
  @base_directory Path.join([".", "data", "jobs"])

  def get_path(url, extension \\ "html") do
    parts = URI.parse(url)
    hash = :crypto.hash(:sha, url) |> Base.encode16(case: :lower)
    {parts.host, "#{hash}.#{extension}"}
  end

  def exists?(path) do
    {directory, filename} = path
    file_path = Path.join([@base_directory, directory, filename])
    File.exists?(file_path)
  end

  def save(path, contents, _overwrite \\ true) do
    {directory, filename} = path
    directory_path = Path.join([@base_directory, directory])
    file_path = Path.join(directory_path, filename)
    File.mkdir_p!(directory_path)
    io_device = File.open!(file_path, [:write, :binary, :utf8])
    :ok = IO.write(io_device, contents)
    :ok = File.close(io_device)
    contents
  end

  def read(path) do
    {directory, filename} = path
    file_path = Path.join([@base_directory, directory, filename])
    File.read!(file_path)
  end
end

url_value = Kino.Input.read(url)
{directory, filename} = Persistence.get_path(url_value)
```

```elixir
exists =
  Persistence.get_path(url_value)
  |> Persistence.exists?()

html =
  if not exists do
    req_html = Req.new(http_errors: :raise)

    html = Req.get!(req_html, url: url_value).body

    Persistence.get_path(url_value)
    |> Persistence.save(html)
  else
    Persistence.get_path(url_value)
    |> Persistence.read()
  end

{:ok, document} = Floki.parse_document(html)

description =
  Floki.find(document, ".breezy-portal .description")
  |> hd()
  |> Floki.children(include_text: false)
  |> Floki.traverse_and_update(fn
    {"li", attrs, [text]} -> {"li", attrs, ["[ ] " <> text]}
    tag -> tag
  end)
  |> Floki.raw_html()

{:ok, markdown} = Pandex.html_to_commonmark(description)

title =
  Floki.find(document, "title")
  |> hd()
  |> Floki.raw_html()

# Since this is a single tag we can just convert it to Markdown directly
markdown_title = title |> String.replace("<title>", "") |> String.replace("</title>", "")

# List items with [ ] get \ prefixed so let's strip them
# Let's also replace the longer list - with less spaces
markdown_content =
  markdown |> String.replace("\\[ \\]", "[ ]") |> String.replace("-   [ ]", "* [ ]")

content = "# #{markdown_title}\n\n" <> markdown_content

Persistence.get_path(url_value, "md")
|> Persistence.save(content)

markdown_title
```

## View Results

```elixir
Kino.Markdown.new(content)
```
